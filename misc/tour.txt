Тур по Борщленгу

"Борщ, как я понял - это очередной способ оскорбления людей с
новомодными предпочтениями, неолдфажскими, которые придумали
эти  самые  олды,  или  13-летние  нигги  по   старлуноми  с 
пубертатом,  в  цели  самоутверждения  и  утверждения  своих 
предпочтений,  с  аргументами  по  типу  -  "так была так па 
стандарту  пидарасы  нам  похуй  что  вы не хатите писать на 
наших  олдфажских  сишках с нормальными раст говно новомодно
!1!!1".  Желаю  что-бы  у  вас  скорее  закончился моральный 
пубертат.  Пошли  нахуй,  псевдо-олдфаги,  которым  похуй на 
мнения." - weflown (30.11.2020)

Борщленг - это  стековый  язык  программирования,  созданный 
для  борщей, чтобы насладится  конкатенативным  миром  шизы. 

Каждый  файл  -   есть  отдельная  программа,  никаких  тебе 
стандартных  библиотек,  импортов  и  всякого  такого, чёрт.  

`$>` - есть обозначение, что это код.
`$` - есть  обозначение, что  это  команда для интерпретатор 
командной строки.

Типы и литералы:
   1917       - целочисленные тип.
   sqrt       - слово, может состоять из всего +-.
   'text'     - строка.
   [ dup * ]  - блок, анонимная функция.
   { 1 2 3 }  - динамический массив. 
   #'{ 1 }'   - цитата кода, что выполняется в runtime.
P.S. Всё, что в круглых скобках - комментарии. 

Управляющие конструкции:
   $> 10 5 > [ 666 ] when (в   нашем  случае   10   больше  5,
                     поэтому на вершину стека поместиться 666 )
   $> 10 5 < [ 'true' ] [ 'false' ] if ( out: 'false' )

   $> [ x get 0 > ] [ x get 1 - x set ] while ( пока переменная  )

Переменные(область видимости оных создаётся в блоках и "словах"):
   $> 0 x set ( x = 0 ) 
   $> x get dup * y set ( y = x * x )

Константы(единая глобальная область):
   $> 'lox' you const
   $> you println ( out: 'lox' )

Блоки:
   $> 7 [ dup * ] call ( 7 * 7 )

   $> [ dup * ] sqrt const
   $> 5 sqrt call println ( out: 25 )

Слова:
   $> : sqrt dup * ;
   $> 8 sqrt println ( out: 64 )

Массив:
   $> { 1 2 3 } 4 append ( { 1 2 3 4 } )
   $> { 1 2 3 } pop ( { 1 2 } 3 )
   $> { 1 2 3 } last ( 3 )
   $> { 1 2 3 } first ( 1 )

   $> { #'{ 1 2 }' 3 } ( вложенный массив )

   $> 1 2 3 3 list ( { 1 2 3 } | создание массива )

Проход по коллекциям:
   $> { 1 2 3 } [ 1 + ] map ( { 2 3 4 } )
   $> { 1 2 3 } [ 1 + ] each ( 2 3 4 )
   $> 'kek' [ println ] each-char
   $> 'hello' [ dup 'l' eq [ 'x' ] if ] map-char 
      ( 'hexxo' )

Хеши(key-value):
   $> { a 1 b 2 } hash ( {a: 1, b: 2} )

   $> { x 0 y 1 } hash point set
   $> point get x of println ( out: 0 ) 


И так далее...
Доков нет, гы. 

